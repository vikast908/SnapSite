<!DOCTYPE html>
<html>
<head>
    <title>GetInspire Icon Generator</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            padding: 20px;
            background: #f0f0f0;
        }
        .canvas-container {
            margin: 20px 0;
            text-align: center;
        }
        canvas {
            border: 1px solid #ccc;
            margin: 10px;
            background: #fff;
        }
        .dark-bg {
            background: #1a1a1a !important;
        }
        button {
            background: #4F46E5;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin: 5px;
            cursor: pointer;
        }
        button:hover {
            background: #4338CA;
        }
        .preview {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>GetInspire Dark-Mode Optimized Icons</h1>

    <div class="preview">
        <div>
            <h3>Light Background</h3>
            <canvas id="canvas16" width="16" height="16"></canvas>
            <canvas id="canvas32" width="32" height="32"></canvas>
            <canvas id="canvas48" width="48" height="48"></canvas>
            <canvas id="canvas128" width="128" height="128"></canvas>
        </div>
        <div>
            <h3>Dark Background</h3>
            <canvas id="canvas16-dark" width="16" height="16" class="dark-bg"></canvas>
            <canvas id="canvas32-dark" width="32" height="32" class="dark-bg"></canvas>
            <canvas id="canvas48-dark" width="48" height="48" class="dark-bg"></canvas>
            <canvas id="canvas128-dark" width="128" height="128" class="dark-bg"></canvas>
        </div>
    </div>

    <div class="canvas-container">
        <button onclick="generateIcons()">Generate Icons</button>
        <button onclick="downloadAll()">Download All Icons</button>
    </div>

    <script>
        function drawLightbulbIcon(canvas, size) {
            const ctx = canvas.getContext('2d');
            const scale = size / 128;

            // Clear canvas
            ctx.clearRect(0, 0, size, size);

            // Colors optimized for both light and dark backgrounds
            const primaryColor = '#4F46E5';     // Indigo
            const secondaryColor = '#7C3AED';   // Purple
            const accentColor = '#F59E0B';      // Amber
            const outlineColor = '#1F2937';     // Dark gray
            const baseColor = '#374151';        // Gray
            const filamentColor = '#FDE047';    // Yellow
            const whiteColor = '#FFFFFF';       // White background

            // Background circle for contrast
            const margin = Math.max(1, 2 * scale);
            const bgRadius = size/2 - margin;

            ctx.beginPath();
            ctx.arc(size/2, size/2, bgRadius, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();
            ctx.strokeStyle = '#E5E7EB';
            ctx.lineWidth = Math.max(1, 1 * scale);
            ctx.stroke();

            // Main bulb dimensions
            const bulbWidth = 32 * scale;
            const bulbHeight = 45 * scale;
            const bulbX = (size - bulbWidth) / 2;
            const bulbY = 20 * scale;

            // Draw main bulb body
            ctx.beginPath();
            const radius = 16 * scale;
            ctx.roundRect(bulbX, bulbY, bulbWidth, bulbHeight, radius);
            ctx.fillStyle = primaryColor;
            ctx.fill();
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = Math.max(1, 2 * scale);
            ctx.stroke();

            // Draw screw threads
            const threadY1 = bulbY + bulbHeight + 4 * scale;
            const threadY2 = threadY1 + 4 * scale;
            const threadMargin = 4 * scale;

            ctx.strokeStyle = baseColor;
            ctx.lineWidth = Math.max(1, 2 * scale);
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(bulbX + threadMargin, threadY1);
            ctx.lineTo(bulbX + bulbWidth - threadMargin, threadY1);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(bulbX + threadMargin * 2, threadY2);
            ctx.lineTo(bulbX + bulbWidth - threadMargin * 2, threadY2);
            ctx.stroke();

            // Draw base
            const baseY = threadY2 + 4 * scale;
            const baseWidth = 24 * scale;
            const baseHeight = 6 * scale;
            const baseX = (size - baseWidth) / 2;

            ctx.beginPath();
            ctx.roundRect(baseX, baseY, baseWidth, baseHeight, 3 * scale);
            ctx.fillStyle = baseColor;
            ctx.fill();
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw filament (for sizes >= 32)
            if (size >= 32) {
                const centerX = size / 2;
                const filamentY = bulbY + 15 * scale;
                const filamentWidth = 12 * scale;

                ctx.strokeStyle = filamentColor;
                ctx.lineWidth = Math.max(1, 2 * scale);
                ctx.lineCap = 'round';

                // Filament lines
                ctx.beginPath();
                ctx.moveTo(centerX - filamentWidth/2, filamentY);
                ctx.lineTo(centerX + filamentWidth/2, filamentY);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(centerX - filamentWidth/3, filamentY + 8 * scale);
                ctx.lineTo(centerX + filamentWidth/3, filamentY + 8 * scale);
                ctx.stroke();
            }

            // Draw inspiration rays (for sizes >= 32)
            if (size >= 32) {
                const rayLength = 8 * scale;
                const centerX = size / 2;

                ctx.strokeStyle = accentColor;
                ctx.lineWidth = Math.max(1, 2 * scale);
                ctx.lineCap = 'round';

                // Top ray
                ctx.beginPath();
                ctx.moveTo(centerX, bulbY - rayLength);
                ctx.lineTo(centerX, bulbY);
                ctx.stroke();

                // Side rays (for sizes >= 48)
                if (size >= 48) {
                    // Top right
                    ctx.beginPath();
                    ctx.moveTo(centerX + bulbWidth/2 + 4*scale, bulbY + 8*scale);
                    ctx.lineTo(centerX + bulbWidth/2 + 4*scale + rayLength, bulbY + 8*scale);
                    ctx.stroke();

                    // Top left
                    ctx.beginPath();
                    ctx.moveTo(centerX - bulbWidth/2 - 4*scale, bulbY + 8*scale);
                    ctx.lineTo(centerX - bulbWidth/2 - 4*scale - rayLength, bulbY + 8*scale);
                    ctx.stroke();
                }
            }
        }

        function generateIcons() {
            const sizes = [16, 32, 48, 128];

            sizes.forEach(size => {
                // Light background version
                const canvas = document.getElementById(`canvas${size}`);
                drawLightbulbIcon(canvas, size);

                // Dark background version (same icon)
                const canvasDark = document.getElementById(`canvas${size}-dark`);
                drawLightbulbIcon(canvasDark, size);
            });
        }

        function downloadCanvas(canvas, filename) {
            const link = document.createElement('a');
            link.download = filename;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function downloadAll() {
            const sizes = [16, 32, 48, 128];

            sizes.forEach(size => {
                const canvas = document.getElementById(`canvas${size}`);
                downloadCanvas(canvas, `${size}.png`);
            });
        }

        // Generate icons on page load
        window.onload = function() {
            generateIcons();
        };

        // Polyfill for roundRect if not supported
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
                this.beginPath();
                this.moveTo(x + radius, y);
                this.lineTo(x + width - radius, y);
                this.arcTo(x + width, y, x + width, y + radius, radius);
                this.lineTo(x + width, y + height - radius);
                this.arcTo(x + width, y + height, x + width - radius, y + height, radius);
                this.lineTo(x + radius, y + height);
                this.arcTo(x, y + height, x, y + height - radius, radius);
                this.lineTo(x, y + radius);
                this.arcTo(x, y, x + radius, y, radius);
                this.closePath();
            };
        }
    </script>
</body>
</html>